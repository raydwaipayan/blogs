<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux_processes | Dwai's blogs</title><meta name=keywords content><meta name=description content="A brief overview about Linux processes. Process A process is simply an instance of an executing program. It consists of an executing program, its current values, state information and the resources used by the operating system to manage the execution of that process.
In a UNIX-based system, each process is isolated from each other. From the viewpoint of the process, it appeats to have control over and access to all the system resources as they were all of their own."><meta name=author content><link rel=canonical href=https://raydwaipayan.github.io/blogs/posts/linux_processes/><link href=https://raydwaipayan.github.io/blogs/assets/css/stylesheet.min.6fdf38588ea13f9fcfd31bf64487e300c670aec39f9ab8cf5473a494b8097993.css integrity="sha256-b984WI6hP5/P0xv2RIfjAMZwrsOfmrjPVHOklLgJeZM=" rel="preload stylesheet" as=style><link rel=icon href=https://raydwaipayan.github.io/blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raydwaipayan.github.io/blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://raydwaipayan.github.io/blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://raydwaipayan.github.io/blogs/apple-touch-icon.png><link rel=mask-icon href=https://raydwaipayan.github.io/blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="Linux_processes"><meta property="og:description" content="A brief overview about Linux processes. Process A process is simply an instance of an executing program. It consists of an executing program, its current values, state information and the resources used by the operating system to manage the execution of that process.
In a UNIX-based system, each process is isolated from each other. From the viewpoint of the process, it appeats to have control over and access to all the system resources as they were all of their own."><meta property="og:type" content="article"><meta property="og:url" content="https://raydwaipayan.github.io/blogs/posts/linux_processes/"><meta property="article:published_time" content="2021-04-02T17:45:25+05:30"><meta property="article:modified_time" content="2021-04-02T17:45:25+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux_processes"><meta name=twitter:description content="A brief overview about Linux processes. Process A process is simply an instance of an executing program. It consists of an executing program, its current values, state information and the resources used by the operating system to manage the execution of that process.
In a UNIX-based system, each process is isolated from each other. From the viewpoint of the process, it appeats to have control over and access to all the system resources as they were all of their own."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://raydwaipayan.github.io/blogs/posts/"},{"@type":"ListItem","position":3,"name":"Linux_processes","item":"https://raydwaipayan.github.io/blogs/posts/linux_processes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux_processes","name":"Linux_processes","description":"A brief overview about Linux processes. Process A process is simply an instance of an executing program. It consists of an executing program, its current values, state information …","keywords":[],"articleBody":"A brief overview about Linux processes. Process A process is simply an instance of an executing program. It consists of an executing program, its current values, state information and the resources used by the operating system to manage the execution of that process.\nIn a UNIX-based system, each process is isolated from each other. From the viewpoint of the process, it appeats to have control over and access to all the system resources as they were all of their own.\nFrom the kernel’s point of view, a process consists of user-space memory containing program code and variables used by that code, and a range of kernel data structures that maintain information about the state of the process. The information recorded in the kernel data structures includes various identifier numbers (IDs) associated with the process, virtual memory tables, the table of open file descriptors, information relating to signal delivery and handling, process resource usages and limits, the current working directory, and a host of other information.\nProcess ID and Parent Process ID Each process has a process ID (PID), a positive integer that uniquely identifies the process on the system. Process IDs are used and returned by a variety of system calls. For example, the kill() system call (Section 20.5) allows the caller to send a signal to a process with a specific process ID\nThe getpid() system call returns the Process ID of the calling process:\n#include  pid_t getpid(void); /* Always successfully returns the process ID of caller */ The init process always has process ID 1. The Linux kernel limits process ids to being less than or equal to 32,767. Once it reaches this number, the kernel resets its process ID counter so that it stars from a lower integer value. On Linux, its reset to 300 rather than 1 as many low-numbered process IDs are in permanent use.\nThe default process ID limit can be changed via the file /proc/sys/kernel/pid_max. On 32 bit systems the limit is 32,768, but on 64-bit systems this number can be anywhere uptil 2^22.\nEach process has a parent that created it. The parent process id can be found out using getppid() system call:\n#include  pid_t getppid(void); /* Always successfully returns parent process ID of caller */ The parent of any process can also be found out by looking at the Ppid field provided in the linux specific file /proc/PID/status.\nNote:: If a child process becomes orphaned because its parent process terminated, the child is adopted by the init process, and subsequent calls to getppid() in the child returns 1.\nProcess Memory layout The memory allocated to each process is composed of a number of parts referred to as segments:\n  The text segment contains the machine language instructions of the process code. The text segment is made read only so that it cannot be accidentally modified by a bad pointer. Since many processes run the same program, it is also made sharable so that a single copy of the program code can be mapped into the virtual address space of the processes.\n  data segments:\n  The initialized data segment contains global and static variables that are explicitly initialized.\n  The uninitialized data segment contains global and static variables that are not expicitly initialized. Before starting the program, the system initializes all memory in this segment to 0. For historical reasons, it is also called the bss segment, a name derived from an old assembler mnemonic for “block started by symbol”.\n  The reason for this separation is that space for uninitialized data is not necessary to be allocated to the program on disk. The executable only needs to store the location and size required for the uninitialized data segment and this space is allocated by the program loader at runtime.\n  The stack is a dynamically growing segment. A function stores the function’s local variables, arguments and return addresses on the stack.\n  The heap is an area from which memory can be allocated dynamically during runtime.\n  Virtual Memory The memory layout we are talking about is the process’s virtual memory. A virtual memory scheme splits the memory used by each process into small units called pages. Correspondingly RAM is divided into a series of page frames of the same size.\nIn order to support this organization the kernel maintains a page table for each process. The page table describes the location of each page in the process’s virtual address space (the set of all virtual memory pages available to the process). Each entry in the page table either indicates the location of a virtual page in RAM or indicates that it currently resides on disk (swap).\nAt any one time, only some of the pages of a program need to be resident in physical memory page frames; these pages form the so-called resident set. Copies of the unused pages of a program are maintained in the swap area—a reserved area of disk space used to supplement the computer’s RAM—and loaded into physical memory only as required.\nIf a process refer to a page that is not currently on physical memory, then a page fault occurs, at which stage kernel suspends execution of the process till the page is loaded from disk into memory.\n","wordCount":"868","inLanguage":"en","datePublished":"2021-04-02T17:45:25+05:30","dateModified":"2021-04-02T17:45:25+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://raydwaipayan.github.io/blogs/posts/linux_processes/"},"publisher":{"@type":"Organization","name":"Dwai's blogs","logo":{"@type":"ImageObject","url":"https://raydwaipayan.github.io/blogs/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://raydwaipayan.github.io/blogs accesskey=h title="Dwai's blogs (Alt + H)">Dwai's blogs</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Linux_processes</h1><div class=post-meta>April 2, 2021</div></header><div class=post-content><h1 id=a-brief-overview-about-linux-processes>A brief overview about Linux processes.<a hidden class=anchor aria-hidden=true href=#a-brief-overview-about-linux-processes>#</a></h1><h2 id=process>Process<a hidden class=anchor aria-hidden=true href=#process>#</a></h2><p>A process is simply an instance of an executing program.
It consists of an executing program, its current values, state
information and the resources used by the operating system to manage
the execution of that process.</p><p>In a UNIX-based system, each process is isolated from each other.
From the viewpoint of the process, it appeats to have control over
and access to all the system resources as they were all of their own.</p><p>From the kernel’s point of view, a process consists of user-space memory
containing program code and variables used by that code, and a range of kernel
data structures that maintain information about the state of the process. The
information recorded in the kernel data structures includes various identifier
numbers (IDs) associated with the process, virtual memory tables, the table of
open file descriptors, information relating to signal delivery and handling,
process resource usages and limits, the current working directory, and
a host of other information.</p><h3 id=process-id-and-parent-process-id>Process ID and Parent Process ID<a hidden class=anchor aria-hidden=true href=#process-id-and-parent-process-id>#</a></h3><p>Each process has a process ID (PID), a positive integer that uniquely identifies the
process on the system. Process IDs are used and returned by a variety of system
calls. For example, the kill() system call (Section 20.5) allows the caller to
send a signal to a process with a specific process ID</p><p>The getpid() system call returns the Process ID of the calling process:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
pid_t <span style=color:#a6e22e>getpid</span>(<span style=color:#66d9ef>void</span>); <span style=color:#75715e>/* Always successfully returns the process ID of caller */</span>
</code></pre></div><p>The init process always has process ID 1.
The Linux kernel limits process ids to being less than or equal to 32,767.
Once it reaches this number, the kernel resets its process ID counter so that
it stars from a lower integer value. On Linux, its reset to 300 rather than 1
as many low-numbered process IDs are in permanent use.</p><p>The default process ID limit can be changed via the file <code>/proc/sys/kernel/pid_max</code>.
On 32 bit systems the limit is 32,768, but on 64-bit systems this number can be
anywhere uptil 2^22.</p><p>Each process has a parent that created it. The parent process id can be found out
using getppid() system call:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
pid_t <span style=color:#a6e22e>getppid</span>(<span style=color:#66d9ef>void</span>); <span style=color:#75715e>/* Always successfully returns parent process ID of caller */</span>
</code></pre></div><p>The parent of any process can also be found out by looking at the Ppid field provided
in the linux specific file <code>/proc/PID/status</code>.</p><p>Note:: If a child process becomes orphaned because its parent process terminated,
the child is adopted by the init process, and subsequent calls to getppid() in the
child returns 1.</p><h3 id=process-memory-layout>Process Memory layout<a hidden class=anchor aria-hidden=true href=#process-memory-layout>#</a></h3><p>The memory allocated to each process is composed of a number of parts
referred to as segments:</p><ul><li><p>The <strong>text</strong> segment contains the machine language instructions of the
process code. The text segment is made read only so that it cannot be
accidentally modified by a bad pointer.
Since many processes run the same program, it is also made sharable so
that a single copy of the program code can be mapped into the virtual
address space of the processes.</p></li><li><p><strong>data</strong> segments:</p><ul><li><p>The <strong>initialized data</strong> segment contains global and static variables
that are explicitly initialized.</p></li><li><p>The <strong>uninitialized data</strong> segment contains global and static variables
that are not expicitly initialized. Before starting the program, the
system initializes all memory in this segment to 0.
For historical reasons, it is also called the <strong>bss</strong> segment, a name
derived from an old assembler mnemonic for &ldquo;block started by symbol&rdquo;.</p></li></ul><p>The reason for this separation is that space for uninitialized data is
not necessary to be allocated to the program on disk. The executable only
needs to store the location and size required for the uninitialized data
segment and this space is allocated by the program loader at runtime.</p></li><li><p>The <strong>stack</strong> is a dynamically growing segment. A function stores the function&rsquo;s
local variables, arguments and return addresses on the stack.</p></li><li><p>The <strong>heap</strong> is an area from which memory can be allocated dynamically during
runtime.</p></li></ul><p><img src=https://raydwaipayan.github.io/blogs/virtual_memory_layout.png alt="virtual memory layout"></p><h3 id=virtual-memory>Virtual Memory<a hidden class=anchor aria-hidden=true href=#virtual-memory>#</a></h3><p>The memory layout we are talking about is the process&rsquo;s virtual memory.
A virtual memory scheme splits the memory used by each process into small units
called pages. Correspondingly RAM is divided into a series of page frames of the
same size.</p><p>In order to support this organization the kernel maintains a page table for each
process. The page table describes the location of each page in the process’s virtual
address space (the set of all virtual memory pages available to the process).
Each entry in the page table either indicates the location of a virtual page in RAM
or indicates that it currently resides on disk (swap).</p><p><img src=https://raydwaipayan.github.io/blogs/page_mapping.png alt="page mapping"></p><p>At any one time, only some of the pages of a program need
to be resident in physical memory page frames; these pages form the so-called
resident set. Copies of the unused pages of a program are maintained in the swap
area—a reserved area of disk space used to supplement the computer’s RAM—and
loaded into physical memory only as required.</p><p>If a process refer to a page that is not currently on physical memory, then a page
fault occurs, at which stage kernel suspends execution of the process till the
page is loaded from disk into memory.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://raydwaipayan.github.io/blogs>Dwai's blogs</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://raydwaipayan.github.io/blogs/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>